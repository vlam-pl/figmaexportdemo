using System.Text;
using System.Text.Json;
using System.Text.RegularExpressions;

if (args.Length < 2)
{
    Console.WriteLine("Figma Token Converter - Converts Figma design tokens to CSS custom properties");
    Console.WriteLine();
    Console.WriteLine("Usage: TokenConverter <input-tokens.json> <output.css> [theme-section]");
    Console.WriteLine();
    Console.WriteLine("Arguments:");
    Console.WriteLine("  input-tokens.json  Path to the Figma tokens JSON file");
    Console.WriteLine("  output.css         Path for the generated CSS file");
    Console.WriteLine("  theme-section      Optional. Theme section to extract (default: '1. Colors/Light')");
    return 1;
}

var inputPath = args[0];
var outputPath = args[1];
var themeSection = args.Length > 2 ? args[2] : "1. Colors/Light";

try
{
    Console.WriteLine($"[TokenConverter] Input: {inputPath}");
    Console.WriteLine($"[TokenConverter] Output: {outputPath}");
    Console.WriteLine($"[TokenConverter] Theme: {themeSection}");

    var tokensJson = File.ReadAllText(inputPath);
    var converter = new FigmaTokenConverter();
    var css = converter.Convert(tokensJson, themeSection);

    var outputDir = Path.GetDirectoryName(outputPath);
    if (!string.IsNullOrEmpty(outputDir) && !Directory.Exists(outputDir))
    {
        Directory.CreateDirectory(outputDir);
    }

    File.WriteAllText(outputPath, css);
    Console.WriteLine($"[TokenConverter] Successfully generated CSS variables.");
    return 0;
}
catch (Exception ex)
{
    Console.Error.WriteLine($"[TokenConverter] Error: {ex.Message}");
    return 1;
}

partial class FigmaTokenConverter
{
    private readonly Dictionary<string, string> _resolvedTokens = new();
    private readonly Dictionary<string, JsonElement> _rawTokens = new();

    [GeneratedRegex(@"\{([^}]+)\}")]
    private static partial Regex TokenReferenceRegex();

    public string Convert(string tokensJson, string themeSection)
    {
        using var doc = JsonDocument.Parse(tokensJson);
        var root = doc.RootElement;

        if (!root.TryGetProperty(themeSection, out var themeElement))
        {
            throw new ArgumentException($"Theme section '{themeSection}' not found in tokens file.");
        }

        CollectTokens(themeElement, "");

        foreach (var (path, element) in _rawTokens)
        {
            if (element.TryGetProperty("value", out var valueElement))
            {
                var value = valueElement.GetString() ?? "";
                var resolvedValue = ResolveTokenReference(value);
                _resolvedTokens[path] = resolvedValue;
            }
        }

        return GenerateCss();
    }

    private void CollectTokens(JsonElement element, string path)
    {
        if (element.ValueKind != JsonValueKind.Object)
            return;

        if (element.TryGetProperty("value", out _) && element.TryGetProperty("type", out _))
        {
            _rawTokens[path] = element;
            return;
        }

        foreach (var property in element.EnumerateObject())
        {
            var childPath = string.IsNullOrEmpty(path) ? property.Name : $"{path}.{property.Name}";
            CollectTokens(property.Value, childPath);
        }
    }

    private string ResolveTokenReference(string value, int depth = 0)
    {
        if (depth > 20)
            return value;

        var match = TokenReferenceRegex().Match(value);
        if (!match.Success)
            return value;

        var referencePath = match.Groups[1].Value;

        if (_rawTokens.TryGetValue(referencePath, out var referencedToken))
        {
            if (referencedToken.TryGetProperty("value", out var refValue))
            {
                var resolvedRefValue = refValue.GetString() ?? "";
                return ResolveTokenReference(resolvedRefValue, depth + 1);
            }
        }

        return value;
    }

    private string GenerateCss()
    {
        var sb = new StringBuilder();
        sb.AppendLine("/* ==========================================================================");
        sb.AppendLine("   Figma Design Tokens - Auto-generated CSS Custom Properties");
        sb.AppendLine("   DO NOT EDIT MANUALLY - This file is generated by TokenConverter");
        sb.AppendLine("   ========================================================================== */");
        sb.AppendLine();
        sb.AppendLine(":root {");

        var semanticTokens = new List<(string name, string value, string category)>();
        var baseTokens = new List<(string name, string value, string category)>();

        foreach (var (path, value) in _resolvedTokens.OrderBy(x => x.Key))
        {
            var cssVarName = ConvertPathToCssVariable(path);
            if (cssVarName != null)
            {
                var category = GetCategory(path);
                if (IsSemanticToken(path))
                    semanticTokens.Add((cssVarName, value, category));
                else
                    baseTokens.Add((cssVarName, value, category));
            }
        }

        // Write base color tokens grouped by category
        WriteTokenGroup(sb, baseTokens, "Base Colors");
        sb.AppendLine();
        WriteTokenGroup(sb, semanticTokens, "Semantic & Component Tokens");

        sb.AppendLine("}");

        return sb.ToString();
    }

    private static void WriteTokenGroup(StringBuilder sb, List<(string name, string value, string category)> tokens, string title)
    {
        sb.AppendLine($"  /* {title} */");

        string? currentCategory = null;
        foreach (var (name, value, category) in tokens.OrderBy(t => t.category).ThenBy(t => t.name))
        {
            if (category != currentCategory)
            {
                if (currentCategory != null)
                    sb.AppendLine();
                currentCategory = category;
            }
            sb.AppendLine($"  {name}: {value};");
        }
    }

    private static bool IsSemanticToken(string path)
    {
        return path.Contains("Semantic") ||
               path.Contains("Neutral.Text") ||
               path.Contains("Neutral.Bg") ||
               path.Contains("Neutral.Border") ||
               path.Contains("Neutral.Fill") ||
               path.Contains("Neutral.Icon") ||
               path.Contains("Neutral.Shadow");
    }

    private static string GetCategory(string path)
    {
        if (path.Contains("Primary")) return "01-Primary";
        if (path.Contains("Success")) return "02-Success";
        if (path.Contains("Warning")) return "03-Warning";
        if (path.Contains("Error")) return "04-Error";
        if (path.Contains("Info")) return "05-Info";
        if (path.Contains("Link")) return "06-Link";
        if (path.Contains("Text")) return "07-Text";
        if (path.Contains("Bg")) return "08-Background";
        if (path.Contains("Border")) return "09-Border";
        if (path.Contains("Fill")) return "10-Fill";
        if (path.Contains("Icon")) return "11-Icon";
        if (path.Contains("Neutral")) return "12-Neutral";
        return "99-Other";
    }

    private static string? ConvertPathToCssVariable(string path)
    {
        var parts = path.Split('.');
        if (parts.Length < 2)
            return null;

        var lastPart = parts[^1];

        // Skip deprecated and todo tokens
        if (path.Contains("_deprecated_") || path.Contains("_todo"))
            return null;

        // Handle semantic tokens
        if (IsSemanticToken(path))
        {
            var kebabName = ToKebabCase(lastPart);
            return $"--ant-{kebabName}";
        }

        // Handle base colors (like Colors.Base.Seablue.6)
        if (path.Contains("Colors.Base"))
        {
            var colorName = parts.Length >= 4 ? parts[^2].ToLowerInvariant() : "";
            var shade = lastPart;
            if (!string.IsNullOrEmpty(colorName) && int.TryParse(shade, out _))
            {
                return $"--ant-{colorName}-{shade}";
            }
        }

        // Handle gradient tokens
        if (path.Contains("Gradient"))
        {
            var kebabName = ToKebabCase(string.Join("-", parts.Skip(parts.Length - 3)));
            return $"--ant-{kebabName}";
        }

        // Handle other neutral tokens
        if (path.Contains("Neutral"))
        {
            var kebabName = ToKebabCase(lastPart);
            return $"--ant-{kebabName}";
        }

        return null;
    }

    private static string ToKebabCase(string input)
    {
        if (string.IsNullOrEmpty(input))
            return input;

        var sb = new StringBuilder();
        for (int i = 0; i < input.Length; i++)
        {
            var c = input[i];
            if (char.IsUpper(c))
            {
                if (i > 0)
                    sb.Append('-');
                sb.Append(char.ToLowerInvariant(c));
            }
            else
            {
                sb.Append(c);
            }
        }
        return sb.ToString();
    }
}
